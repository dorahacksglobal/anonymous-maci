# Anonymous MACI 匿名投票方案

> Felix Cai 2022/07/23

## 投票执行时序

### 启动准备

管理员（coordinator）创建一个此次投票加密消息所使用的私钥 `m` 及其对应公钥 `M`；

在合约中配置本次投票允许的最大用户数量，合约中设置 `user_tree_depth` = log(5, max_users_count)；

在合约中配置本次投票选项的个数；

### 用户注册

用户需要首先创造一个参与此次投票所使用的账户的私钥 `x`；
> 目前采用了通过用户以太坊账户在钱包中签名固定特殊字段的方式来生成一个难以预测的私钥，以减少用户在前端的操作成本。但是如果希望投票安全性更高，用户应当自己创建一个完全随机的私钥来使用并且自己储存和管理。

有资格的用户向合约提交登记自己的账户，合约记录每一个用户的账户摘要：`S` = { h | h = hash(x_i, salt_i) }，更新用户账户集合的默克尔根 `root_S`；

### 投票开始

用户选择投票的项目和票数等信息，将整个投票方案编码成一个固定尺寸的消息 `V`；
> TODO: 编码方式未定。由于尺寸固定，最终可能会不得不限制用户投票的最大项目数和单项目的最大投票数。

用户计算 inactive 标记 `i` = hash(x, "INACTIVE")；

用户生成一个一次性加密账户私钥 `k` 及其对应公钥 `K`，生成一个随机数 `nonce`；

用户生成投票消息 `msg` = poseidonEncrypt([i, V], M ^ k, nonce)；

用户生成一个证明 `zkp_u`，包括以下约束：

- 用户私钥存在与注册用户的集合中；
- 用户 inactive 标记计算正确；
- 用户投票消息生成正确。

用户向合约提交 `[nonce, msg, K]` 及 `zkp_u`，合约验证通过后接受这一次用户投票消息；

### 计票阶段

管理员离线逆序处理所有合约上通过验证的用户投票消息，处理时遵循以下步骤：

- 根据共享密钥 `K ^ m` 及 `nonce` 解密消息；
- 验证是否已经见过 inactive 标记：
  - 是，忽略该条投票记录；
  - 否，解码投票信息 `V`，并将投票结果加至总结果中。

管理员整理所有见过的 inactive 标记，并整理为有序排列的集合 `I`，并计算其默克尔根 `root_I`；
> inactive 标记集合的规模始终和用户账户集合的规模一致。

管理员提交一个证明 `zkp_i`，包括以下约束：

- 有一组有序排列的数据，且其默克尔根为 `root_I`。

合约记录 `root_I` 值；

管理员分批提交投票信息的处理证明 `zkp_v`，包括以下约束：

- 一组用户消息将会将投票结果从初状态迁移至终状态；
- inactive 标记集合状态迁移；

合约严格控制管理员处理消息时的顺序，并且验证证明，更新各状态迁移情况；

所有消息处理完后，允许管理员提供最终态的结果和 salt，在合约上验证并披露结果。

<!-- ## 数据可见性

下表展示了在整个投票的生命周期中将会出现的所有数据，以及他们各自的可见性。

| 符号 | 名称 | 类型 | 当前投票用户可见 | 其他投票用户可见 | 管理员可见 |
| - | - | - | - | - | - | -->

## 差异

| MACI | A-MACI |
| - | - |
| 用户告知管理员自己是谁（以便于确认公钥是否正确） | 用户通过 zkp 来证明自己是注册用户的一员 |
| 管理员计票时的电路可以确保投票参数必须是合法的 | 能够被用户提交上链的的投票信息一定是合法的 |
| 用户的剩余 voice credit 会在计票时的状态中体现，余额不足的时候剩余的投票信息会被忽略 | 用户一次性给出所有选票，之后会记录一个特殊的 inactive 标记，以便忽略用户后续的投票信息 |

